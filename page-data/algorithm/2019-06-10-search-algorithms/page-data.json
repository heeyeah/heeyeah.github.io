{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/2019-06-10-search-algorithms/","result":{"data":{"site":{"siteMetadata":{"title":"Heeye Blog","author":"heeye","siteUrl":"https://heeyeah.github.io","comment":{"disqusShortName":"","utterances":"heeyeah/heeyeah.github.io"},"sponsor":{"buyMeACoffeeId":"heeyeah"}}},"markdownRemark":{"id":"e8a3427c-e239-51bc-a576-54dc714db183","excerpt":"출처 Search algorithm에 대해 찾다가 Java로 자세히 설명한 Posting이 있어서 내가 필요한 수준으로 정리한다. Search algorithm 뭔가를 찾는 알고리즘은 어디든 많이 쓰인다. Arrays, List, Map과 같은 자료구조에 저장된 데이터들을 찾을 때도 그렇다. Java API에서 사용하는 search algorithm들과 유명한 search algorithm 두, 세개만 정리하고자 한다. Java Collections API Linear Search Binary…","html":"<h2 id=\"출처\" style=\"position:relative;\"><a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>출처</h2>\n<p>Search algorithm에 대해 찾다가 Java로 자세히 설명한 <a href=\"https://stackabuse.com/search-algorithms-in-java/\">Posting</a>이 있어서 내가 필요한 수준으로 정리한다.</p>\n<h2 id=\"search-algorithm\" style=\"position:relative;\"><a href=\"#search-algorithm\" aria-label=\"search algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Search algorithm</h2>\n<p>뭔가를 찾는 알고리즘은 어디든 많이 쓰인다. Arrays, List, Map과 같은 자료구조에 저장된 데이터들을 찾을 때도 그렇다. Java API에서 사용하는 search algorithm들과 유명한 search algorithm 두, 세개만 정리하고자 한다.</p>\n<ul>\n<li><a href=\"#java-collections-api\">Java Collections API</a></li>\n<li><a href=\"#linear-search\">Linear Search</a></li>\n<li><a href=\"#binary-search\">Binary Search</a></li>\n<li>그 외는 정말 잘 정리된 포스팅을 볼 것! <a href=\"https://stackabuse.com/search-algorithms-in-java/\">Search Algorithm</a></li>\n</ul>\n<h3 id=\"java-collections-api\" style=\"position:relative;\"><a href=\"#java-collections-api\" aria-label=\"java collections api permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Java Collections API</h3>\n<p>자바 API에서 사용하고 있는 검색 알고리즘이 무엇인지를 살펴본 후 그 알고리즘에 대해 공부하면 좋을 것 같다.</p>\n<h4 id=\"arrays\" style=\"position:relative;\"><a href=\"#arrays\" aria-label=\"arrays permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Arrays</h4>\n<p>Arrays API에는 <code class=\"language-text\">java.util.BinarySearch</code> 메소드가 존재한다. OpenJDK version에서는 iterative form의 서치를 사용하고 있다. (binary search에는 iterative, recursive form 2가지가 존재한다.)</p>\n<h4 id=\"ths-list-interface\" style=\"position:relative;\"><a href=\"#ths-list-interface\" aria-label=\"ths list interface permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ths List Interface</h4>\n<p>리스트 인터페이스는 searching하는 두가지 메소드가 있는데, <code class=\"language-text\">indexOf()</code>와 <code class=\"language-text\">contains()</code> 이다.\n<code class=\"language-text\">indexOf()</code> 메소드는 리스트에 element가 존재하면 index를 반환하고 없으면 -1을 반환한다.\n<code class=\"language-text\">contains()</code> 메소드는 element 포함 유무에 따라 boolean 값을 반환하는데, 내부적으로는 <code class=\"language-text\">indexOf()</code> 메소드를 call한다.</p>\n<p>이 리스트 인터페이스는 Sequential Search를 사용하며, 그래서 time complexity는 <code class=\"language-text\">O(N)</code>이다.</p>\n<h4 id=\"the-map-interface\" style=\"position:relative;\"><a href=\"#the-map-interface\" aria-label=\"the map interface permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The Map Interface</h4>\n<p>맵은 key-value 쌍으로 구성된 데이터 구조이다. 자바에서 맵 인터페이스는 <code class=\"language-text\">HashBased</code> 검색과 Binary Search Tree를 사용한다.</p>\n<p><code class=\"language-text\">java.util.HashMap</code> 클래스는 key의 hash-value를 사용한다. hash된 올바른 key값과 good hashing algorithm을 사용한 맵에서 element를 조회하는 것은 <code class=\"language-text\">O(1)</code>이다.</p>\n<p><code class=\"language-text\">java.tuil.TreeMap</code> 클래스는 내부적으로 <strong>Red-Black Tree</strong> 알고리즘을 사용한다. Red-Black Tree 알고리즘은 self-balancing 바이너리 서치 트리 형태이다. 이 tree에 추가되는 element들은 자동적으로 sorting된 방식으로 저장된다. time complexity는 <code class=\"language-text\">O(log(N))</code>이다.</p>\n<h4 id=\"the-set-interface\" style=\"position:relative;\"><a href=\"#the-set-interface\" aria-label=\"the set interface permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The Set Interface</h4>\n<p>셋은 unique element를 가지는 데이터 구조인데, 내부적으로 Map 인터페이스레 wrapping되어 있다. 맵과 같이 <code class=\"language-text\">Binary</code>와 <code class=\"language-text\">Hash-based</code> 서치알고리즘을 사용한다.</p>\n<p><strong>간단하 보면 Sequential Search(=Linear Search)와 Binary Search에 대한 이야기가 주이다. 이 두가지 알고리즘은 최소한 제일 기본이라는 말!</strong></p>\n<h3 id=\"linear-search\" style=\"position:relative;\"><a href=\"#linear-search\" aria-label=\"linear search permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Linear Search</h3>\n<p>Linear Search 또는 Sequential Search라고 불리는 이 알고리즘은 세상 간단한 검색 알고리즘이다. 순차 검색 알고리즘이라고 부르는데, 찾고자 하는 값을 맨 앞에서부터 끝까지 차례대로 찾아 나가는 것이다. brute-force 알고리즘이다. 다 해보는 것! 전체 검색!</p>\n<ul>\n<li>Time complexity : O(N)</li>\n<li>Space complexity : O(1)</li>\n<li>활용\nsmall 사이즈거나 정렬되지 않은 데이터에서 사용하기 적합하다. 집합의 크기가 커질수록 time complexity가 늘어나기 때문에 비효율적이다.</li>\n</ul>\n<h3 id=\"binary-search\" style=\"position:relative;\"><a href=\"#binary-search\" aria-label=\"binary search permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Binary Search</h3>\n<p>Binary Search 또는 Logarithmic Search라고 불리는 이 알고리즘은 빠른 검색 시간을 장점으로 아주 많이 쓰이는 검색 알고리즘이다. 이 검색 알고리즘은 <strong>Divide and Conquer</strong>, 분할정복 알고리즘을 사용하고 데이터가 미리 sort된 상태여야 한다.</p>\n<p>과정은 이렇다.\n똑같이 반으로 나누고! 목표 element를 향해서 하나씩 비교하면서 중간점을 향해 달려간다!</p>\n<p>만약 내가 찾고자하는 element를 찾으면 거기서 끝이다. <strong>목표 요소가 중간 요소보다 작거나 큰지 여부에 따라 배열의 적절한 파티션을 나누고 선택해서 요소를 계속 찾는다. 이게 핵심이다!</strong></p>\n<p>firstIndex와 lastIndex가 만나는 지점에서 검색은 끝나고, 이떄 찾지 못하면 그 element는 없다고 봐야 한다.</p>\n<p>binary search를 구현하는 방법은 iterative와 recursive 2가지 방법이 존재한다.</p>\n<ul>\n<li>Time complexity : O(log(N))</li>\n<li>Space complexity : O(1) (recursive의 경우 worst case는 O(log(N)))</li>\n<li>활용\n대부분의 라이브러리에 이 알고리즘이 쓰인다. sort되어있고 데이터 양이 많을 때 사용된다.</li>\n</ul>","frontmatter":{"title":"Search Algorithm Basic","date":"June 10, 2019"}}},"pageContext":{"slug":"/algorithm/2019-06-10-search-algorithms/","previous":{"fields":{"slug":"/java/2019-06-09-java8/"},"frontmatter":{"title":"Java8 특징 정리","category":"java","draft":false}},"next":{"fields":{"slug":"/java/2019-06-19-optional-class/"},"frontmatter":{"title":"Optional이란?","category":"java","draft":false}}}},"staticQueryHashes":["3128451518","521680639"]}